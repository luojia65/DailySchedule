# OS实验报告

[仓库链接](https://github.com/luojia65/spicy-os)

这部分我一边跟进教程，一边学习操作系统的理论知识，还尝试完善相关的开发生态。

实验零主要是学习一些安装Rust和环境的方法。由于我们暂时使用nightly版本的Rust，
需要注意部分问题。Rust的安装是非常容易的，而且比C语言好的是有统一的包管理器
称作Cargo。这比往常使用C语言开发操作系统要方便不少，也要简单很多，出错了也容易
找到来源。这部分的实验非常简单，相信许多已经入门Rust的开发者都可以迅速完成。

## 1. 第一到三章

实验一、二、三主要是RISC-V架构的知识，包括操作系统通用的中断、页表等等。
这些编写每个操作系统是都需要接触的知识。

### 第一章

实验一里介绍了RISC-V的中断系统。这也包括了相关的CSR寄存器，还有一些中断机制。
RISC-V的陷入包括异常和中断，其中中断分为三个特权级、三个种类，共占用9个编号，
中断是可以通过`mstatus`里的总开关打开或关闭的。
我们在后续的实验中，应该特别注意哪些属于异常，哪些属于中断。
异常分为十几个类型，包括非法指令、页错误、读写地址错误等等，环境调用也属于异常。
RISC-V提供了特殊的`ecall`和`ebreak`指令，其中`ecall`能产生环境调用异常，
这在后续的系统调用里是非常有用的。

实验中特别介绍了时钟中断的处理方法。今天主流的指令集架构里，
几乎都专门给系统时钟提供了支持，这类设计一般都是为操作系统的时间轮片调度提供便利。
时钟中断是涉及上下文调度的，我们在涉及上下文的处理函数里，
必须保存所有31个寄存器（不考虑x0），
而且还要保存`sstatus`和`sepc`，因为切换回来之后，可能就在不同的上下文内。
如果只涉及异常处理，比如在页错误里面重新处理页表，或者系统调用，
其实只保存16个寄存器就可以了（不包含s0-s11、tp、gp和sp），
因为它们能代表我们需要恢复的上下文，其它寄存器不涉及上下文切换，意义不会变化。

实验中使用断点异常作为测试，这应该是最容易得到中断的方法。
这类异常直接就可以运行，不需要打开开关。
但是时钟的运行是需要开关打开的，需要设置`sie`和`sstatus`相关的位，
才能打开时钟的运行，从而触发时间中断。

中断系统里，所有的异常都是可以处理的。要达到这一点，我们需要编写处理函数。
这个处理函数和中断处理的模式需要放入`mtvec`里面。
中断处理有两个模式，一个是直接模式，一个是向量模式，本次实验中使用直接模式。
处理函数需要对齐到4字节。

需要注意的是RISC-V标准提供的中断系统是不支持嵌套的。要使用嵌套中断，
可以使用赛昉提出的PLIC，也可以使用芯来提出的ECLIC，这些就看芯片是如何支持的了。
这些是M层中断，一般都在SBI里处理完成，SBI只会给我们委托一些异常，
S层的操作系统作者可能不需要考虑太深。

### 第二章

//todo

## 题外话

其实我很想把RISC-V翻译成“第五代精简指令集技术”，因为简短性，保留外文原文。
我在编写各类文章、博客的时候，除了专有名词，尽量全部使用汉语翻译，是为了让读者理解更清晰。
