# OS实验报告

[仓库链接](https://github.com/luojia65/spicy-os)

这部分我一边跟进教程，一边学习操作系统的理论知识，还尝试完善相关的开发生态。

实验零主要是学习一些安装Rust和环境的方法。由于我们暂时使用nightly版本的Rust，
需要注意部分问题。Rust的安装是非常容易的，而且比C语言好的是有统一的包管理器
称作Cargo。这比往常使用C语言开发操作系统要方便不少，也要简单很多，出错了也容易
找到来源。这部分的实验非常简单，相信许多已经入门Rust的开发者都可以迅速完成。

## 1. 第一到三章

实验一、二、三主要是RISC-V架构的知识，包括操作系统通用的中断、页表等等。
这些编写每个操作系统是都需要接触的知识。

### 第一章

实验一里介绍了RISC-V的中断系统。这也包括了相关的CSR寄存器，还有一些中断机制。
RISC-V的陷入包括异常和中断，其中中断分为三个特权级、三个种类，共占用9个编号，
中断是可以通过`mstatus`里的总开关打开或关闭的。
我们在后续的实验中，应该特别注意哪些属于异常，哪些属于中断。
异常分为十几个类型，包括非法指令、页错误、读写地址错误等等，环境调用也属于异常。
RISC-V提供了特殊的`ecall`和`ebreak`指令，其中`ecall`能产生环境调用异常，
这在后续的系统调用里是非常有用的。

实验中特别介绍了时钟中断的处理方法。今天主流的指令集架构里，
几乎都专门给系统时钟提供了支持，这类设计一般都是为操作系统的时间轮片调度提供便利。
时钟中断是涉及上下文调度的，我们在涉及上下文的处理函数里，
必须保存所有31个寄存器（不考虑x0），
而且还要保存`sstatus`和`sepc`，因为切换回来之后，可能就在不同的上下文内。
如果只涉及异常处理，比如在页错误里面重新处理页表，或者系统调用，
其实只保存16个寄存器就可以了（不包含s0-s11、tp、gp和sp），
因为它们能代表我们需要恢复的上下文，其它寄存器不涉及上下文切换，意义不会变化。

实验中使用断点异常作为测试，这应该是最容易得到中断的方法。
这类异常直接就可以运行，不需要打开开关。
但是时钟的运行是需要开关打开的，需要设置`sie`和`sstatus`相关的位，
才能打开时钟的运行，从而触发时间中断。

中断系统里，所有的异常都是可以处理的。要达到这一点，我们需要编写处理函数。
这个处理函数和中断处理的模式需要放入`mtvec`里面。
中断处理有两个模式，一个是直接模式，一个是向量模式，本次实验中使用直接模式。
处理函数需要对齐到4字节。

所有的中断发生时，`sepc`的值都是下一个指令的地址。
但是异常发生时，`sepc`都是当前指令的地址。因为一个指令发生了异常，
它很可能需要在处理后重新执行一次，比如缺页异常，可以把这个页补上然后再试一遍。
`ecall`被归类到异常里面，所以需要把`sepc`加上4，来跳过原来的指令。

需要注意的是RISC-V标准提供的中断系统是不支持嵌套的。要使用嵌套中断，
可以使用赛昉提出的PLIC，也可以使用芯来提出的ECLIC，这些就看芯片是如何支持的了。
这些是M层中断，一般都在SBI里处理完成，SBI只会给我们委托一些异常，
S层的操作系统作者可能不需要考虑太深。

### 第二章

这一章讲了物理内存的探测和分配。其实也涉及了大量Rust alloc库的内容和设计方式。
其实SBI运行时会给一个设备树，从这里面是能扫描到所有的内存块，
本次实验出于简单考虑，直接把地址固化在代码里面。
还大致使用了堆分配的算法，在初始化代码里加载一个堆，这样就能用Box和Arc等等了。

需要注意的事项不多。每个段最好对齐到4K，方便后面分配初始的段内存。

### 第三章

这一章是比较重要的部分，虚拟地址到物理地址，涉及的难点是页表。

因为每个操作系统的地址空间设计都会不一样，初始的页表也会不一样。本次实验里初始页表
暂时是固化在代码里面的，也可能会有其它的设计。

RISC-V的虚拟地址涉及几个概念：虚拟地址、物理地址、虚拟页号、物理页号。
其中虚拟地址与整数寄存器宽度相等，物理地址可能大于整数寄存器的位数。
虚拟页号和物理页号都是地址的一部分，高位如果不够，都用符号扩展，第0到11位都是索引位，
剩余的都是页号的位置。无论如何，物理页号和虚拟页号都能装进整数寄存器宽度的页表项中。

页号是分成几部分的，虚拟页号的每一部分都有9位（32位下有10位）。
这个设计可能是由统一的4KB页大小决定的。
需要注意的是，如果自己设计页表，页表的级数和物理页号的对齐方法是有关的，
需要仔细查看文档后继续编写。

页表项的低10位是大量的标记，表示每个页表项的权限等等。包括最低的V位代表是否有效。
其实如果这一位是0，页表项仍然可以存放一些有用的信息，这个就另外说了。

页表都是有好多级的，包括Sv32是两级，64位下Sv39是三级，Sv48是四级。
页表的级数从高到低，最先查询的页表级数最大，最后查询的级数最小为零。
最终需要把最高级页表的物理地址存到`satp`里面。`satp`也包含页表的模式，
还有一个地址空间标识符，本次实验还没有用到，其它地方会用得到。

还有一个就是研发处理器核的人需要关心的，就是快表。页表如果还只从内存里直接查那就太慢了，
有个快表就快一点，相当于是某种缓存。
出于这种考虑，`satp`写完之后，一定要记得使用`sfence.vma`刷新快表，否则访问会出问题。

既然我们有页表了，虚拟地址也有了，这样操作系统就能编译到虚拟地址启动了。
即使编译到虚拟地址，M层的SBI运行时调用操作系统时，还是物理地址，
这时候地址的转换暂时是有效的，访问临时变量也是有效的，因为一般是按相对地址去访问。
需要建立一个初始映射，这个就和操作系统的设计有关系，把物理地址映射到虚拟地址上。
跳转到虚拟地址，需要把起始虚拟地址的值写到代码里面，用汇编指令去读取，然后跳转。
这时候还要准备一个比较小的启动栈。

初始映射有了之后就可以准备内核重映射了。这里就涉及到大量代码工作，
把内核的每个段映射到每个地址，这样就可以解引用然后运行了。

还有一个页面置换的问题，涉及到缺页异常怎么处理，然后要不要把哪个页置换到磁盘里，
把新的页拿出来到内存里面。这里其实DMA就可以派上用场了，还有很多特性。
这个到后面遇到了再解决，这章实验就做简单的了解。

页表的调试是非常难的，尤其是还没有进入虚拟地址的时候页表的调试，
这时候通常需要对照反汇编代码，反复测试后再继续。

## 2. 第四章

开始有进程和线程了。进程是资源分配的最小单位，线程是时间轮片调度的最小单位。
每个线程都有自己的栈和上下文保存区，线程都是属于进程的。
每个进程都有所有线程共享的资源。

有了线程，我们需要处理器去运行线程。每个处理器都有活跃和休眠的线程。
休眠的线程都是在等待外部资源可用的，此时不应当为它分配处理器时间。

涉及线程的调度都需要存储和读出上下文。这个上下文和陷入的上下文不同，必须保存所有的31
个非零寄存器，还要保存`sepc`和`sstatus`。
线程的调度是借助时钟中断完成的，它必须发生在操作系统初始化完毕之后，所以初始化的过程中
不能发生时钟中断，此时应先将时钟中断的开关关闭。

从S层上升到U层唯一可以使用的指令是`sret`。这里有一个技巧，就是把上升到U层的上下文保存
和陷入的上下文保存合二为一，做到同一个中断处理过程里面。

这一块Rust代码里怎么写就比较有讲究了，需要先做一个调度器，然后在时钟中断里面调用它，
每个核的调度器都是自己的，会轮番调出想要运行的线程，直到所有的线程都结束。
需要注意一个休眠线程，如果全都是休眠线程就阻塞等待中断，如果休眠线程也没有就退出。
时钟中断里还需要切换页表。

有了线程模型，其它扩展的实验就可以开始做了。

## 3. 第五到六章

做到这一步难度会大一点，如果前几章没有写好，会导致很多问题，需要彻底掌握前面几章的知识，
熟练调试各个内容，甚至可以多做几次，然后总结出最好的设计。

第五章设计到设备树、驱动和简单的文件系统了。到这里和RISC-V的架构关联可能变小了，
因为设备树可以是这个操作系统特定的设计，它将大量的硬件抽象到统一的结构里面，
做成一个树，以便后续的驱动能占用一个叶子节点或一整个子树，提供更多的设备或者提供特定的服务。

SBI运行时里，初始的设备树是由运行时提供的。在其它运行时和架构，可能是以其它方法提供的。
这样我们针对硬件适配的节点，就可以很好地做出针对它的支持。

QEMU提供了一个内存映射读写的设备抽象，我们可以先从运行时读入这个设备，
然后使用已经写好的读写方法去操作它。用这个设备可以制作文件系统。
更深入的设计应该使用中断响应，这样上面的线程就不需要等待了。

然后就可以开始做第六章了，这部分主要是怎么写用户程序的问题。我们的操作系统提供S到U的部分，
U的部分就由用户程序使用。我们新建了一个工程，然后为它实现类似于Rust std库的接口，
然后就能使用类似于std库了。

每当用户进程将要运行，先运行一个线程。从可执行文件里读取这个程序的内容和入口点，把它们映射
到内存里面，这样就创建了上下文。
我们还需要创建用户的页表映射，以便在每个进程分离的空间里运行程序。
然后保存入口点到异常恢复指针`sepc`，调用恢复后就开始运行了。

要用std库，那std库如何实现呢？这就要涉及系统调用。系统调用要使用`ecall`指令，
把参数传到固定的寄存器里面。而操作系统接收到中断后，应当根据不同寄存器的值，
做特定的操作，然后结束异常处理程序。由于`ecall`不需要被处理第二次，
应当设置`sepc`的值，跳过`ecall`指令本身，这一步千万别忘了。

然后就可以做各种各样的模块了。标准输入和输出啊，很多，只要原理对上就行了。
如果要在S层访问U层的内存，不要忘了开启`sstatus.SUM`位，否则访问会失败。

## 结束语

这次实验做下来，思路很清晰，也让我体会各种工程设计的不同点。我可以快速验证新的想法。
Rust和RISC-V在操作系统开发上优势都非常明显，未来学习操作系统来看，的确是较好的选择。
