# 第二阶段实验日志

## 第1天

## 第2天

这两天进入了K210的小组，了解了一些同学。
下午听了国科大同学一生一芯处理器的报告。

简介，开发过程，经验，展望

芯片基本情况。处理器：“果壳”，9级双发射，RV64IMAC，M、S、U，L1、L2，流片内有高速缓存，chisel语言，有外设，Linux可用
110纳米工艺，200mW@350MHz，100脚封装
有板卡，运行Linux，图形界面，运行虚拟机，网络，动态语言脚本。PCIE的SSD上运行，挂载在NVME的设备上
不用SDRAM时，可以到200MHz。CoreMark：1.49/MHz

2019/9月到12月开发结束。前端开发过程包括高速缓存、Sv39到时序优化、适配系统等各个过程。
板卡设计失误，险些报废芯片，后修复。如果未来需要调试软件，很难想到问题会出现在硬件上。
采访：流片困难吗？同学们都设计前端，较少接触硬件。前端上逻辑、时序设计要求都非常高。流片的时间节点压力非常大。
流片的压力非常大，如果有问题，后面的软件就无法修改。冻结时间提前一个月。
后端和前端的优化暂时不多。四个月的时间是比较困难的，需要很多团队的支持，包括开源工具，有支持基础。
从零开始做会是比较难的，后续的推广可能不是每年都能做这么复杂的事情。

项目的复杂性是什么时候认识到的，如何应对？程序出现问题之后，需要关注自己项目的正确性和验证环节的正确性，
如果一开始只会一些简单的应用，就很容易出现一些漏洞。
复杂的项目需要注意版本管理的方法。
这个项目的复杂性在后期各个部分的验证中。前期先把核看成黑盒，但是后期需要做软件测试，需要了解核内是怎么构成的。
外设有很多种，需要了解所有的外设代码。转变心态。
用类似于面向对象的思想去处理核。慢慢进入黑盒的各个部分，再定位问题在哪个部件，最后找到问题。

Chisel强调面向对象，和Verilog的区别，类似于Java和汇编语言。
使用了一套处理器在线差分测试仿真验证的框架。因为qemu只能搭建几个周期的寄存器值等等，比对状态，使用了nemu。
验证CPU模块：核内可以差分测试，核外不行。核外可以使用回环测试，比如验证以太网模块等等，可以采用短接TX、RX的方法。
第二级缓存预取部分，发现漏洞可以解决，难的在于在没有漏洞的前提下如何提升性能。
需要使用回归测试。写脚本，遍历所有的设置。

印象最深刻的漏洞。跑了33亿条指令才出现问题。是跨页指令的问题，需要有仿真机制才能找到，定位这个问题相当困难。
GPIO的四个引脚。已经到ASIC过程，发现IO板的模型，“OEN”引脚的“N”其实表示低位有效，没有接对。变量名没起好，方言不同。
快表地址对的，取出来的地址错了。发现是软件没有刷新快表。
分支预测器对高速缓存有一些隐含条件，修复后性能就回去了。

适配操作系统的过程中有哪些困难？分为流片之前的开发和流片后的测试。
Sv39分页，内核和用户暂时没有超过1GB，共享了一个巨页，用户空间的内存能被内核发现。这其实是软件问题。
FreeRTOS没有坑，它非常小。还有一个RT-Thread，添加了RV64的支持，比如把指令lw改成ld等等。
还有一个ALIGN(4)改成ALIGN(8)的问题，属于RV32移植到RV64里面。
xv6没刷新快表，出现一些机制支持不正确。用官方的xv6跑芯片，一定要刷新快表。涉及到Linux系统的进程分支操作。
软件中断没有实现，导致远程刷新页表没有实现，远程的快表没有刷新。硬件上暂时是单核，不实现机器软中断。
如果一生一芯要支持多核，就必须实现软中断。
闪存只能读4字节，没法读8字节，而且没法写，只能擦除。放在2字节对齐的4字节指令会出问题，闪存里面只能跑4字节指令。
misa的问题。导致收到的是M模式的缺页，而不是S模式。
虚拟动态共享对象vDSO，允许在不陷入内核的前提下做一些简单的调用。

## 第3天

前一天晚上和老师交流。有一个做操作系统协程的灵感，就是首先有一个线程，在线程上运行所有的协程，协程只会在它的任务完成后
交接，就不用保存上下文。然后一旦发生中断，保存的是这个线程的上下文。然后线程和协程共用一个调度器。
对于async/await生态，是一个相当好的处理方法。用网页服务器举例，最高效的方法是直接编写专用操作系统，
比较普通的方法是做一个用户层的调度器。我们如果能在操作系统里支持协程，就能性能相当高地给出一些异步运行时。

早上和向老师、小组同学交流。我继续开发rustsbi软件，先把rCore教程的系统跑在现在的SBI实现里面。
后续的SBI实现还包含很多模块，包括硬件线程监测和管理模块，还需要很多事情要做。包括跨核刷新页表也是这样的。

下午到清华伯克利深圳学院听了RIOS组织的报告。
RISC-V和arm系区别的是，标准是免费的，然后有授权的设计反而是最多的，封闭的设计可能差不多，RISC-V存在大量的免费设计。这里稍微提了一下法律的问题，如何防范专利上糟糕的问题，然后开源的核在法律上是一个新的领域。

RIOS组织正在达成一个五年目标，提出了一个称作PicoRio的开放架构。希望能减少开发者的开销，有一款文档详细的单板计算机，功率要和树莓派板子对标。
PicoRio的开发分为三个阶段，第一阶段希望实现异构多核的处理器，要实现还在草稿中的RISC-V的动态语言J扩展，跑Linux，跑Chrome OS的内核。希望在今年秋天发布第一个版本。
第二个阶段希望支持图形处理器，希望支持虚拟机监视器，希望有一个WebAssembly的运行时。第三个阶段希望有更多的工业软件和更好的性能。

J扩展正在草稿阶段，可能要增加两个功能。还在讨论过程中。
增加一些CSR，增加一些地址保护的模块。非常早期。

晚上听了Sipeed工程师的讲座。首先工程师介绍了MaixPy，它的使用方法，如何移植，常见容易有问题的地方。
MaixPy是用micropython语法，快速运行AI功能的一个软件包。
K210有硬件的神经网络加速器。使用了micropython，这能帮助新手更快地入门上手。
micropython是解释性语言，有缺点，不过它的优点是学习成本不高，有一定的开发效率。

工程师讲了micropython的一个例子，但其实使用Rust写嵌入式是更方便的。我给出下面的例子：

```rust
#[riscv_rt::entry]
fn main() {
    let dp = pac::Peripheral::take().unwrap();
    // ... 配置时钟，创建总线等等
    let mut lcd = LcdXxxx::new(spi); // 将包含初始化过程
    let sensor = SensorXxx::new(bus);
    loop {
        let img = sensor.snapshot();
        lcd.show(&img);
    }
}
```

其实也不会更复杂，而且工业上Rust语言的所有权能带来更多的便利，也不需要手动去找一些漏洞，缩短开发时间，
还能无缝使用社区丰富的库或者厂商提供的库，未来还能和async/await的生态结合上。
Micropython初学是非常快的，但是做到应用上可能就缺少一些灵活性。不过Micropython依然是非常有价值的语言和框架。
然后还有神经网络加速器的应用，和普通的流程相似，也有输入和模型，会输出结果。
模型和输入都放进处理器，然后由处理器与硬件加速器通讯，最终由处理器得到输出的结果。

大概的代码，首先调用神经网络加速器的加载函数，加载特定的模型，得到模型变量。
然后打开图片，把图片和模型变量都传入加速器，得到输出。最终输出就包含结果，可以做很多科学计算了。
模型在电脑上有几十兆的空间，但是嵌入式芯片上只有几兆的容量，就需要压缩模型。
后续还要做的过程包括简单的用户界面，分享模型的网站，移植Linux等等。
工程师简单介绍了platformIO环境的开发流程。

吴学长分享了K210编写操作系统的很多工作。有一位学长把1991年的Linux0.11版本移植成功。
王润基学长移植了rCore这个有内存管理单元的系统。后来有没有内存管理单元的Linux也可以移植。

当前移植K210的进展，首先暂时使用已有的OpenSBI。它会初始化所有的寄存器，然后输出一些CPU信息，
最终将跳转到内核。第二点是在运行的时候支持SBI调用。第三种是初始化跳转到系统，可以跳转到固定的位置，可以和内核一起编译，
也可以动态决定要跳转到的位置。
QEMU上是跳转到固定的位置的，只能跳转到特定的位置。但是在K210上最新的QEMU自带的OpenSBI不能工作，
只有旧版本的OpenSBI可以工作。这样能过lab0了。然后M到S的中断委托也是需要处理的。

中断处理有两个：PLIC，转发外部中断。CLINT，转发软件和时钟中断。

## 第4天

今天经过一些调试，rustsbi能在QEMU里运行了。下一步是在K210上运行。
之前调试最久的一个问题是，SBI的legacy扩展，返回值的位置在a0寄存器，
然而新的扩展全都是a1寄存器，对于唯一一个能有返回值的调试控制台读入扩展，会出现一些问题。
添加一些代码之后就好了。

K210有非常多的坑，希望能把学长的文档都看一遍之后，再想着移植到这个目标上。

下午华为的工程师来做关于欧拉操作系统的演讲。原来的内核，需要先上传再支持，接近一年的时间之后，才会适配新的芯片。
这就是为什么华为要开发欧拉系统，是在华为的芯片发布的当天，就有一个可用的操作系统。
开源社区共享共建的模式，需要具备独立演进能力。
