# 冬季异步内核项目

## 第1天（1月19日）

大概启动了异步内核项目。我把基于async/await或者无栈协程的内核，叫做异步内核。

### 1. 异步内核中的协程

异步内核和传统的同步内核，差别在于：一个在内核层面提供协程，一个只提供线程。
线程和协程的区别在于，线程需要运行较长的时间，要触发时间中断，让多个线程能并行地运行。
每当时间中断出现时，线程的上下文应当保存，然后取出下一个线程的上下文以供运行。
协程运行的时间较短，通常可以在一个时间片内完成。一个协程的运行完毕之后，它占有的栈就已经全部退出，所以协程之间的切换不需要保存上下文。

Rust语言的async/await和无栈协程是同一个概念。我的理解不一定对，粗略的给出应用层来看，async/await的调度关系。

```rust
async fn main() {
    let mut lazer_gun = LazerGun::new();
    lazer_gun.charge().await;
    for _ in 0..5 {
        lazer_gun.shoot().await;
    }
}
```

这段程序中出现了一个async，两个await。`async fn`定义的函数，都是异步执行的函数，
这是`fn(...) -> impl Future<Output = ...>`的语法糖缩写，将返回一个`Future`。
这个返回的结构体不会被执行，应当用`poll`去执行，我们通常不会直接去`poll`，
而是去使用`.await`语法。

`await`语法将代码分成了几个部分。每两个`await`之间，都是一个无栈协程。
程序将会执行一定的“让出”操作，将当前的执行过程交由运行环境。
这样Rust程序将异步代码切分成更多的小块，更有利于调度和运行。

### 2. 超时与外部中断

编写操作系统内核时，通常首先假设用户程序是正确无误的。但当协程的任务占用处理器过久，
在没有时钟中断的前提下，处理器只能运行这一个协程，一段时间无法响应其它的应用程序。
这就是超时问题，要解决这个问题，内核必须在占用时间过长的时候做出反应。

一种解决超时问题的方法，就是限定每个协程运行的最长时间。在最长的时间到达时，
操作系统内核立即中断，保存这个协程的上下文，把剩余的部分和其它的协程一起调度，继续运行。
这里，“线程”的思想就回来了。应用开发者基于协程内核开发时，知道如果协程占用时间过久，
调度性能在某种意义上就会退化到“线程”的水平，就知道应当使用异步开发的思路开发应用。

另一种比较应急的方法也能处理超时问题，就是在协程超时的时候，终止它所在的进程。
这之后协程的后续部分不再运行。这种方法属于底牌，尽量少用，应当用于一些必须让出资源的情况，
否则相比传统的操作系统内核，用户体验会非常不好。

外部中断可能出现在任何时候，它是操作系统和外界沟通的一部分，不能因为内核的性质变化了，
就忽视外部中断的处理流程。类似的思路，有两种针对外部中断的处理方法。
一种是直接中断当前的协程，保存上下文，然后立即调度处理外部中断的协程。
另一种是将外部中断的协程加入队列，然后继续运行当前的协程。第一种优点在于实时性好，
第二种优点在于上下文切换开销较小。

通常协程会被运行完毕，然而强制中断发生时，当前的协程只运行了一半。
这种运行到一半的状态，我叫它“半协程”。“半协程”就像线程一样被保存在内核中，
它包含了一个上下文，要调度到它的时候，不像普通协程一样直接可以运行，而应当先恢复上下文。
“半协程”的逻辑编写完毕后，可以用于对超时和外部中断的解决方案中。

### 3. 测试内核的调度效率

内核的调度效率可以使用一个数字表示，它代表一段时间内，用户程序运行的时间和总时间的比。
它是在0到1之间的一个小数，理想情况下，这个数字应当接近于1。
我们认为多道程序同时运行时，调度开销总是存在的，于是这个数字只能接近于1而不等于1。
它可以用来衡量内核的调度效率，越接近于1，说明内核的调度设计越好。

要在RISC-V下测试调度效率，有两个方案。一种是在内核里添加一个计数器。
计数器将在调度开始和结束时，记录下此时的时刻。
相减的差值就是应用和调度占用的时间，一段时间内累加计算，就能得到表示调度性能的数字。
还有一种方案是在SBI里添加计数器，不要把M层的时钟中断委托到S层，而是让M层在时钟中断发生时，
记下当时的时刻，随后再设置mie、mip等位，把中断手动分配给S层。剩下的思路和内核计数器相似。

两种方案的优劣是，第二种可以无缝更换内核，不需要重新编译，然而只适用于RISC-V平台。
第一种适用于更多的平台，然而需要重新编译和调试内核。

通过这些方案，我们最终得到表示内核调度开销的数字。我们编写同步和异步内核时，比较这个数字，
就能定量地说明不同内核在调度效率上的区别。

### 4. 面向应用层的异步内核

操作系统最终要承载大量的应用。对应用来说，系统调用是必要的渠道。
在基于线程的内核中，系统调用将会陷入内核，切换到内核线程，由它完成内核提供的系统调用功能；
这之后通过指令返回到用户态，继续运行用户的应用程序。

我们认为，基于协程的内核，系统调用也由一个协程处理。应用调用系统调用时，应用的协程就结束了。
系统调用的协程结束后，内核将调度应用接下来的协程。
也就是说，协程内核在系统调用过程中，涉及到三个协程的切换关系，而不是两个线程的切换。

```rust
async fn count_audio_devices(token_str: &str) -> usize {
    // +++ 第一个协程开始
    let token_hash = hash_token(token_str); // 同步操作
    // --- 第一个协程结束
    //使用这个函数后，操作系统将会使用协程，完成处理任务
    let mut cur = syscall(MODULE_AUDIO, LIST_AUDIO_DEVICES, token_hash).await;
    // +++ 第三个协程开始
    let mut ans = 0;
    while let Some(ptr) = cur { // 同步操作
        let nxt = unsafe { ptr.as_ref() };
        ans += 1;
        cur = nxt;
    }
    ans
    // --- 第三个协程结束
}
```

在RISC-V下，系统调用通过ecall指令实现。这里，“ecall”指令也是我们陷入内核的方法，
也顺便解决了上文中如何“让出资源”的问题；“ecall”就可以是很多语言中的“yield”语句。

陷入内核和结束陷入通常被认为是开销较大的操作。陷入和结束本身，可能只涉及到特权级的修改，
占大头的操作反而是保存上下文和切换虚拟内存空间。如果排除掉保存上下文的开销，
陷入和结束本身很可能是不需要很大开销的。这里的观点不是很成熟，需要对照硬件实现来校对和了解。

### 5. 未来的异步内核

现在的任务管理器里，通常出现“线程数”这个选项。这代表了当前的进程正在运行的线程。
未来，可能出现的是“每秒协程数”这样的情况。

所有的设备和文件系统都可以做成协程。希望异步内核得到验证后，能实际推出一些应用，
给出更多的测试，来获得更好的推广效果。

## 第2天（1月20日）

今天忙别的事情了，休息一天。

阅读了下面的文章：

[200行讲清楚Future是什么](https://github.com/wyfcyx/osnotes/blob/master/Rust/future-in-200-lines.md)，由吴一凡学长翻译
[异步Rust简介](https://github.com/wyfcyx/osnotes/blob/master/Rust/rust-async-introduction/rust-async-new.pdf)，吴一凡学长

先前对async/await的理解似乎不是很准确？明天继续做这一部分。
